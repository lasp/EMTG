# Copyright (c) 2024 The Regents of the University of Colorado.
# All Other Rights Reserved.

"""
make_missionoptions_python.py
=============================
This file contains the make_PyEMTG_MissionOptions function.

"""

def make_PyEMTG_MissionOptions(OptionsDefinitions, now, path = '.'):
    """
    Function for automatically creating a MissionOptions.py file based on a csv of mission options.

    Parameters
    ----------
    OptionsDefinitions : List of dict entries
        Dict entries that define the options to be added to MissionOptions.py
    now : string
        A string of the current time.
    path : string, optional
        Path to directory in which to write MissionOptions.py. The default is '.'

    Returns
    -------
    None.

    """
    with open(path + "PyEMTG/MissionOptions.py", "w") as file:
        file.write('"""\n')
        file.write('MissionOptions.py\n')
        file.write('========================\n')
        file.write('auto-generated by make_EMTG_missionoptions_journeyoptions.py\n')
        file.write('\n')
        file.write('"""')
        file.write('\n')
        file.write('import JourneyOptions\n')
        file.write('\n')

        file.write('class MissionOptions(object):\n')
        file.write('\n')

        tab = '    '
        file.write(tab + '"""\n') # start np-style comment block
        file.write('\n')
        file.write(tab + "MissionOptions class is used to read/write .emtgopt files and hold mission option variables.\n")
        
        file.write('\n')
        file.write(tab + '"""\n') # end np-style comment block

        file.write('    #************************************************************************************constructor\n')
        file.write('    def __init__(self, optionsFileName = None):\n')

        for option in OptionsDefinitions:
            if option['name'] == 'user_data':
                #file.write('        self.' + option['name'] + ' = {} #' + option['comment'] + '\n')
                file.write('        self.' + option['name'] + ' = {}\n')
                file.write(tab + tab + '"""' + option['comment'] + '"""\n')
            elif 'string' in option['dataType']:
                file.write('        self.' + option['name'] + ' = "' + str(option['defaultValue']) + '"\n')
                file.write(tab + tab + '"""' + option['comment'] + '"""\n')
            else:
                file.write('        self.' + option['name'] + ' = ' + str(option['defaultValue']) + '\n')
                file.write(tab + tab + '"""' + option['comment'] + '"""\n')
            
        file.write('        \n')    
        file.write('        #empty master decision and constraint vectors - these exist only for interface with PyEMTG GUI and PEATSA\n')
        file.write('        self.trialX = []\n')
        file.write('        self.ManeuverConstraintDefinitions = []\n')
        file.write('        self.BoundaryConstraintDefinitions = []\n')
        file.write('        self.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        \n')
        file.write('        if optionsFileName == None:\n')
        file.write('            self.Journeys = [JourneyOptions.JourneyOptions()]\n')
        file.write('            self.number_of_journeys = 1\n')
        file.write('        else:\n')
        file.write('            self.Journeys = []\n')
        file.write('            self.parse_mission(optionsFileName)\n')
        file.write('        self.filename = ""\n')
        file.write('        self.success = 1\n')
        file.write('        self.ActiveJourney = 0\n')
        file.write('        self.AU = 1.49597870691e+8\n')
        file.write('        self.G = 6.674280000000000367e-20\n')
        file.write('        self.g0 = 9.806649999999999423\n')
        file.write('        \n')

        file.write('   \n')
        file.write('    #************************************************************************************parse\n')
        file.write('    def parse_mission(self, optionsFileName):\n')
        file.write('        self.filename = optionsFileName\n')
        file.write('        \n')
        file.write('        inputFile = []\n')
        file.write('        lineNumber = 0\n')
        file.write('        from os.path import isfile\n')
        file.write('        if isfile(self.filename):\n')
        file.write('            inputFile = open(optionsFileName, "r")\n')
        file.write('            self.success = 1\n')
        file.write('        else:\n')
        file.write('            print("Unable to open", optionsFileName, "EMTG Error")\n')
        file.write('            return\n')
        file.write('        \n')
        file.write('        while True:\n')
        file.write('            line = inputFile.readline()\n')
        file.write('            if not line:\n')
        file.write('                break\n')
        file.write('            #strip off the newline character\n')
        file.write('            line = line.rstrip("\\n\\r ")\n')
        file.write('            \n')
        file.write('            lineNumber += 1\n')
        file.write('            \n')
        file.write('            #if we got this far, then this is a line worth reading\n')
        file.write('            #Note that unlike EMTG proper, PyEMTG does NOT length or bounds-check input files. But if you try to run an invalid .emtgopt, EMTG will notify you and help you fix it.\n')
        file.write('            \n')
        file.write('            if line.strip(\'\\r\') != "":\n')
        file.write('                if line[0] != "#":\n')
        file.write('                    #this is an active line, so it is space delimited\n')
        file.write('                    linecell = [entry.rstrip(" \\r\\n") for entry in line.split(" ")]\n')
        file.write('                    \n')

        ifelse = ''
        for option in OptionsDefinitions:
            length = 1
            if 'std::vector' in option['dataType']:
                length = len(option['defaultValue'])
            converter_in = ''
            converter_out = ''

            if 'double' in option['dataType']:
                converter_in = 'float('
                converter_out = ')'
            elif 'string' not in option['dataType']:#bool, size_t, int, time_t, or any enum
                converter_in = 'int('
                converter_out = ')'
            
            
            file.write('                    ' + ifelse + 'if linecell[0] == "' + option['name'] + '":\n')
            if option['name'] == 'user_data':
                file.write('                        self.user_data = dict()                                                          \n')
                file.write('                        full_notes = line.lstrip("user_data").lstrip(" ").rstrip(" \\r\\n")                \n')
                file.write('                        if ":" in full_notes or full_notes.replace(" ","") != "":                        \n')
                file.write('                            full_notes = full_notes.split(":")                                           \n')
                file.write('                                                                                                         \n')
                file.write('                            for note in full_notes:                                                      \n')
                file.write('                                var = note.lstrip(\'("\').split(",")[0].rstrip(\'"\')                        \n')
                file.write('                                val = eval(note.lstrip("(").lstrip(var + \'"\').lstrip(", ").rstrip(") ")) \n')
                file.write('                                self.user_data.update({var:val})                                         \n')
            elif option['name'] == 'spice_utility_extension':    
                file.write('                        if len(linecell) > 1:\n')
                file.write('                            self.' + option['name'] + ' = ' + converter_in + 'linecell[1]' + converter_out + '\n')
                file.write('                        else:\n')
                file.write('                            self.' + option['name'] + ' = ""\n')
                
            else:
                if length == 1:
                    file.write('                        self.' + option['name'] + ' = ' + converter_in + 'linecell[1]' + converter_out + '\n')
                else:
                    file.write('                        self.' + option['name'] + ' = [' + converter_in + 'entry' + converter_out + ' for entry in linecell[1:]]\n')
            file.write('                  \n')
            ifelse = 'el'

        
        file.write('                    elif linecell[0] == "BEGIN_JOURNEY":\n')
        file.write('                        self.Journeys.append(JourneyOptions.JourneyOptions(inputFile, lineNumber))\n')
        file.write('        \n')
        file.write('        self.number_of_journeys = len(self.Journeys)\n')
        file.write('        \n')

        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            self.Journeys[journeyIndex].universe_folder = self.universe_folder\n')
        file.write('        \n')
        file.write('        self.ConvertDecisionVector()\n')
        file.write('        self.AssembleMasterDecisionVector()\n')
        file.write('        self.AssembleMasterConstraintVectors()\n')
        file.write('        \n')

        file.write('    #************************************************************************************write\n')
        file.write('    def write_options_file(self, optionsFileName, writeAll = True):\n')
        file.write('        \n')
        file.write('        #Disassemble the master constraint and decision vectors, just in case we modified them. We want any changes to be reflected at the Journey level.\n')
        file.write('        self.DisassembleMasterDecisionVector()\n')
        file.write('        self.DisassembleMasterConstraintVectors()\n')
        file.write('        \n')
        file.write('        with open(optionsFileName, "w+") as optionsFile:\n')
        file.write('            optionsFile.write("#EMTGv9 .emtgopt file version 2\\n")\n')
        file.write('            optionsFile.write("\\n")\n')
        file.write('            \n')

        for option in OptionsDefinitions:
            name = option['name']

            if name == 'user_data':
                file.write('            optionsFile.write("#Enter any user data that should be appended to the .emtg file.\\n")\n')
                file.write('            optionsFile.write("#This is typically used in python wrappers\\n")\n')
                file.write('            optionsFile.write("user_data ")\n')
                file.write('            first_entry = True\n')
                file.write('            for entry in self.user_data.keys():\n')
                file.write('                if first_entry == True:\n')
                file.write('                    first_entry = False\n')
                file.write('                else:\n')
                file.write('                    optionsFile.write(":")\n')
                file.write('                optionsFile.write(\'("\' + entry + \'",\')\n')
                file.write('                if isinstance(self.user_data[entry],str):\n')
                file.write('                    optionsFile.write("\'" + str(self.user_data[entry]) + "\')") \n')
                file.write('                else:\n')
                file.write('                    optionsFile.write(str(self.user_data[entry]) + ")")\n')
                file.write('            optionsFile.write("\\n")\n')
                file.write('            optionsFile.write("\\n")\n')

            else:
                defaultValue = ''
                if option['dataType'] == 'std::string':
                    defaultValue = '"' + str(option['defaultValue']) + '"'
                else:
                    defaultValue = str(option['defaultValue'])

                file.write('            if (self.' + name + ' != ' + defaultValue + ' or writeAll):\n')
                file.write('                optionsFile.write("#' + option['description'] + '\\n")\n')
                if 'std::vector' in option['dataType']:
                    elementType = option['dataType'].replace('std::vector<','').replace('>','')
                    file.write('                optionsFile.write("' + name + '")\n')
                    file.write('                for entry in self.' + name + ':\n')
                    if 'bool' in option['dataType']:
                        file.write('                    optionsFile.write(" " + str(int(entry)))\n')
                    else:
                        file.write('                    optionsFile.write(" " + str(entry))\n')
                    file.write('                optionsFile.write("\\n")\n')
                else:
                    if 'bool' in option['dataType']:
                        file.write('                optionsFile.write("' + name + ' " + str(int(self.' + name + ')) + "\\n")\n')
                    else:
                        file.write('                optionsFile.write("' + name + ' " + str(self.' + name + ') + "\\n")\n')
                file.write('    \n')        
        
        file.write('            \n')
        file.write('            optionsFile.close()\n')
        file.write('            \n')
        file.write('            for Journey in self.Journeys:\n')
        file.write('                Journey.write(optionsFileName, writeAll)\n')
        file.write('            \n') 

        
        file.write('    #************************************************************************************convert decision vector\n')
        file.write('    def ConvertDecisionVector(self):\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.ConvertDecisionVector(self.ParallelShootingStateRepresentation, self.PeriapseBoundaryStateRepresentation)\n')
        file.write('        \n')
        
        
        file.write('    #************************************************************************************assemble master decision vector\n')
        file.write('    def AssembleMasterDecisionVector(self):\n')
        file.write('        self.trialX = []\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            for entry in self.Journeys[journeyIndex].trialX:\n')
        file.write('                self.trialX.append(["j" + str(journeyIndex) + entry[0], entry[1]])\n')
        file.write('        \n')

        file.write('    #************************************************************************************assemble master constraint vectors\n')
        file.write('    def AssembleMasterConstraintVectors(self):\n')
        file.write('        self.ManeuverConstraintDefinitions = []\n')
        file.write('        self.BoundaryConstraintDefinitions = []\n')
        file.write('        self.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            for entry in self.Journeys[journeyIndex].ManeuverConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.ManeuverConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.ManeuverConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('            for entry in self.Journeys[journeyIndex].BoundaryConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.BoundaryConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.BoundaryConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('            for entry in self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.PhaseDistanceConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.PhaseDistanceConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('        \n')
        
        file.write('    #************************************************************************************disassemble master decision vector\n')
        file.write('    def DisassembleMasterDecisionVector(self):\n')
        file.write('        #clear the journey trialX vectors\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.trialX = []\n')
        file.write('        \n')
        file.write('        for entry in self.trialX:\n')
        file.write('            journeyIndex = int(entry[0][0:entry[0].find("p")].strip("j"))\n')
        file.write('            \n')
        file.write('            if journeyIndex < len(self.Journeys):\n')
        file.write('                self.Journeys[journeyIndex].trialX.append([entry[0][entry[0].find("p"):], entry[1]])\n')
        file.write('        \n')

        file.write('    #************************************************************************************disassemble master constraint vectors\n')
        file.write('    def DisassembleMasterConstraintVectors(self):\n')
        file.write('        #clear the journey constraint vectors\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.ManeuverConstraintDefinitions = []\n')
        file.write('            Journey.BoundaryConstraintDefinitions = []\n')
        file.write('            Journey.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        \n')
        file.write('        for entry in self.ManeuverConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].ManeuverConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('            \n')
        file.write('        for entry in self.BoundaryConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].BoundaryConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('            \n')
        file.write('        for entry in self.PhaseDistanceConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('        \n')
        file.write('        \n')
        file.write('    #************************************************************************************getJourneyIndex()\n')
        file.write('    def getJourneyIndex(self, journeyNameString):\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            if self.Journeys[journeyIndex].journey_name == journeyNameString:\n')
        file.write('                return journeyIndex\n')
        file.write('        \n')
        file.write('        #if you get this far, something went wrong                                                                 \n')
        file.write('        raise Exception("Journey \'" + journeyNameString + "\' not found.")  \n')
